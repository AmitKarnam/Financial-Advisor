from fastapi import FastAPI, Request
from fastapi.responses import StreamingResponse, FileResponse
from app.agents.coordinator import handle_user_input, get_workflow_status, reset_workflow
from app.utils.sse import create_sse_event
import os
import logging

app = FastAPI()

@app.post("/chat")
async def chat(request: Request):
    """
    Main chat endpoint - orchestrates three agents:
    1. Conversational agent collects user profile via chat.
    2. Summary agent extracts structured JSON profile from conversation.
    3. Recommendation agent generates investment advice using MCP data.
    """
    try:
        body = await request.json()
        user_input = body.get("message")
        
        if not user_input:
            # Return error as SSE stream
            async def error_stream():
                yield await create_sse_event("Please provide a message.")
            return StreamingResponse(error_stream(), media_type="text/event-stream")
        
        # Route through the multi-agent coordinator
        stream = await handle_user_input(user_input)
        return StreamingResponse(stream, media_type="text/event-stream")
        
    except Exception as e:
        logging.error(f"Error in chat endpoint: {e}")
        async def error_stream():
            yield await create_sse_event("Sorry, I encountered an error. Please try again.")
        return StreamingResponse(error_stream(), media_type="text/event-stream")

@app.get("/chat")
async def get_initial_message():
    """
    Get initial message without user input - triggers the conversational agent to start the workflow.
    """
    try:
        # This will trigger the initial system prompt from the conversational agent
        stream = await handle_user_input()
        return StreamingResponse(stream, media_type="text/event-stream")
    except Exception as e:
        logging.error(f"Error in initial message: {e}")
        async def error_stream():
            yield await create_sse_event("Welcome! I'm here to help you with your financial planning. Let's start by discussing your current financial situation.")
        return StreamingResponse(error_stream(), media_type="text/event-stream")

@app.get("/status")
async def get_status():
    """Get current workflow status for the frontend"""
    try:
        status = await get_workflow_status()
        return status
    except Exception as e:
        logging.error(f"Error getting status: {e}")
        return {
            "current_stage": "conversation",
            "profile_extracted": False,
            "recommendations_ready": False,
            "error": "Could not retrieve status"
        }

@app.post("/reset")
async def reset_conversation():
    """Reset the conversation and start over"""
    try:
        result = await reset_workflow()
        return result
    except Exception as e:
        logging.error(f"Error resetting conversation: {e}")
        return {"status": "error", "message": "Could not reset conversation"}

@app.get("/profile")
async def get_extracted_profile():
    """
    Get the extracted user profile (JSON) from the summary agent.
    """
    try:
        from app.agents.coordinator import coordinator
        if coordinator.user_profile:
            return {
                "profile_available": True,
                "profile": coordinator.user_profile,
                "extracted_at": coordinator.profile_extracted_at if hasattr(coordinator, 'profile_extracted_at') else None
            }
        else:
            return {"profile_available": False}
    except Exception as e:
        logging.error(f"Error getting profile: {e}")
        return {"error": "Could not retrieve profile"}

@app.get("/recommendations")
async def get_recommendations():
    """
    Get investment recommendations generated by the recommendation agent (uses MCP data).
    """
    try:
        from app.agents.coordinator import coordinator
        if coordinator.recommendations:
            return {
                "recommendations_available": True,
                "recommendations": coordinator.recommendations
            }
        else:
            return {"recommendations_available": False}
    except Exception as e:
        logging.error(f"Error getting recommendations: {e}")
        return {"error": "Could not retrieve recommendations"}

@app.get("/")
def read_index():
    return FileResponse(os.path.join(os.path.dirname(__file__), "index.html"))

# Health check endpoint
@app.get("/health")
async def health_check():
    """
    Health check endpoint for monitoring all three agents.
    """
    return {
        "status": "healthy",
        "agents": {
            "coordinator": "active",
            "conversational": "active",
            "summarization": "active", 
            "recommendation": "active"
        }
    }

if __name__ == "__main__":
    import uvicorn
    # Set up logging
    logging.basicConfig(level=logging.INFO)
    uvicorn.run(app, host="0.0.0.0", port=8000, reload=True)